{
  "version": 3,
  "sources": ["../../echarts/lib/coord/cartesian/Cartesian.js", "../../echarts/lib/coord/cartesian/Cartesian2D.js", "../../echarts/lib/coord/cartesian/Axis2D.js", "../../echarts/lib/coord/axisAlignTicks.js", "../../echarts/lib/coord/cartesian/Grid.js"],
  "sourcesContent": ["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar Cartesian = /** @class */function () {\n  function Cartesian(name) {\n    this.type = 'cartesian';\n    this._dimList = [];\n    this._axes = {};\n    this.name = name || '';\n  }\n  Cartesian.prototype.getAxis = function (dim) {\n    return this._axes[dim];\n  };\n  Cartesian.prototype.getAxes = function () {\n    return zrUtil.map(this._dimList, function (dim) {\n      return this._axes[dim];\n    }, this);\n  };\n  Cartesian.prototype.getAxesByScale = function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  };\n  Cartesian.prototype.addAxis = function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n    this._dimList.push(dim);\n  };\n  return Cartesian;\n}();\n;\nexport default Cartesian;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport Cartesian from './Cartesian.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nexport var cartesian2DDimensions = ['x', 'y'];\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\nvar Cartesian2D = /** @class */function (_super) {\n  __extends(Cartesian2D, _super);\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'cartesian2d';\n    _this.dimensions = cartesian2DDimensions;\n    return _this;\n  }\n  /**\r\n   * Calculate an affine transform matrix if two axes are time or value.\r\n   * It's mainly for accelartion on the large time series data.\r\n   */\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    }\n    // Accelerate data to point calculation on the special large time series data.\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = invert([], m);\n  };\n  /**\r\n   * Base axis will be used on stacking.\r\n   */\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n  Cartesian2D.prototype.containZone = function (data1, data2) {\n    var zoneDiag1 = this.dataToPoint(data1);\n    var zoneDiag2 = this.dataToPoint(data2);\n    var area = this.getArea();\n    var zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);\n    return area.intersect(zone);\n  };\n  Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1];\n    // Fast path\n    if (this._transform\n    // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.\n    && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return applyTransform(out, data, this._transform);\n    }\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));\n    return out;\n  };\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n  Cartesian2D.prototype.pointToData = function (point, clamp) {\n    var out = [];\n    if (this._invTransform) {\n      return applyTransform(out, point, this._invTransform);\n    }\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);\n    return out;\n  };\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n  /**\r\n   * Get rect area of cartesian.\r\n   * Area will have a contain function to determine if a point is in the coordinate system.\r\n   */\n  Cartesian2D.prototype.getArea = function (tolerance) {\n    tolerance = tolerance || 0;\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]) - tolerance;\n    var y = Math.min(yExtent[0], yExtent[1]) - tolerance;\n    var width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;\n    var height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;\n    return new BoundingRect(x, y, width, height);\n  };\n  return Cartesian2D;\n}(Cartesian);\n;\nexport default Cartesian2D;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { __extends } from \"tslib\";\nimport Axis from '../Axis.js';\nvar Axis2D = /** @class */function (_super) {\n  __extends(Axis2D, _super);\n  function Axis2D(dim, scale, coordExtent, axisType, position) {\n    var _this = _super.call(this, dim, scale, coordExtent) || this;\n    /**\r\n     * Index of axis, can be used as key\r\n     * Injected outside.\r\n     */\n    _this.index = 0;\n    _this.type = axisType || 'value';\n    _this.position = position || 'bottom';\n    return _this;\n  }\n  Axis2D.prototype.isHorizontal = function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  };\n  /**\r\n   * Each item cooresponds to this.getExtent(), which\r\n   * means globalExtent[0] may greater than globalExtent[1],\r\n   * unless `asc` is input.\r\n   *\r\n   * @param {boolean} [asc]\r\n   * @return {Array.<number>}\r\n   */\n  Axis2D.prototype.getGlobalExtent = function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  };\n  Axis2D.prototype.pointToData = function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  };\n  /**\r\n   * Set ordinalSortInfo\r\n   * @param info new OrdinalSortInfo\r\n   */\n  Axis2D.prototype.setCategorySortInfo = function (info) {\n    if (this.type !== 'category') {\n      return false;\n    }\n    this.model.option.categorySortInfo = info;\n    this.scale.setSortInfo(info);\n  };\n  return Axis2D;\n}(Axis);\nexport default Axis2D;", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { getPrecisionSafe, round } from '../util/number.js';\nimport IntervalScale from '../scale/Interval.js';\nimport { getScaleExtent } from './axisHelper.js';\nimport { warn } from '../util/log.js';\nimport { increaseInterval, isValueNice } from '../scale/helper.js';\nvar mathLog = Math.log;\nexport function alignScaleTicks(scale, axisModel, alignToScale) {\n  var intervalScaleProto = IntervalScale.prototype;\n  // NOTE: There is a precondition for log scale  here:\n  // In log scale we store _interval and _extent of exponent value.\n  // So if we use the method of InternalScale to set/get these data.\n  // It process the exponent value, which is linear and what we want here.\n  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);\n  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);\n  var alignToSplitNumber = alignToTicks.length - 1;\n  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);\n  var scaleExtent = getScaleExtent(scale, axisModel);\n  var rawExtent = scaleExtent.extent;\n  var isMinFixed = scaleExtent.fixMin;\n  var isMaxFixed = scaleExtent.fixMax;\n  if (scale.type === 'log') {\n    var logBase = mathLog(scale.base);\n    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];\n  }\n  scale.setExtent(rawExtent[0], rawExtent[1]);\n  scale.calcNiceExtent({\n    splitNumber: alignToSplitNumber,\n    fixMin: isMinFixed,\n    fixMax: isMaxFixed\n  });\n  var extent = intervalScaleProto.getExtent.call(scale);\n  // Need to update the rawExtent.\n  // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'\n  if (isMinFixed) {\n    rawExtent[0] = extent[0];\n  }\n  if (isMaxFixed) {\n    rawExtent[1] = extent[1];\n  }\n  var interval = intervalScaleProto.getInterval.call(scale);\n  var min = rawExtent[0];\n  var max = rawExtent[1];\n  if (isMinFixed && isMaxFixed) {\n    // User set min, max, divide to get new interval\n    interval = (max - min) / alignToSplitNumber;\n  } else if (isMinFixed) {\n    max = rawExtent[0] + interval * alignToSplitNumber;\n    // User set min, expand extent on the other side\n    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {\n      interval = increaseInterval(interval);\n      max = rawExtent[0] + interval * alignToSplitNumber;\n    }\n  } else if (isMaxFixed) {\n    // User set max, expand extent on the other side\n    min = rawExtent[1] - interval * alignToSplitNumber;\n    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {\n      interval = increaseInterval(interval);\n      min = rawExtent[1] - interval * alignToSplitNumber;\n    }\n  } else {\n    var nicedSplitNumber = scale.getTicks().length - 1;\n    if (nicedSplitNumber > alignToSplitNumber) {\n      interval = increaseInterval(interval);\n    }\n    var range = interval * alignToSplitNumber;\n    max = Math.ceil(rawExtent[1] / interval) * interval;\n    min = round(max - range);\n    // Not change the result that crossing zero.\n    if (min < 0 && rawExtent[0] >= 0) {\n      min = 0;\n      max = round(range);\n    } else if (max > 0 && rawExtent[1] <= 0) {\n      max = 0;\n      min = -round(range);\n    }\n  }\n  // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale\n  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;\n  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;\n  // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.\n  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);\n  intervalScaleProto.setInterval.call(scale, interval);\n  if (t0 || t1) {\n    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    var ticks = intervalScaleProto.getTicks.call(scale);\n    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {\n      warn(\n      // eslint-disable-next-line\n      \"The ticks may be not readable when set min: \" + axisModel.get('min') + \", max: \" + axisModel.get('max') + \" and alignTicks: true\");\n    }\n  }\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Grid is a region which contains at most 4 cartesian systems\r\n *\r\n * TODO Default cartesian\r\n */\nimport { isObject, each, indexOf, retrieve3, keys } from 'zrender/lib/core/util.js';\nimport { getLayoutRect } from '../../util/layout.js';\nimport { createScaleByModel, ifAxisCrossZero, niceScaleExtent, estimateLabelUnionRect, getDataDimensionsOnAxis } from '../../coord/axisHelper.js';\nimport Cartesian2D, { cartesian2DDimensions } from './Cartesian2D.js';\nimport Axis2D from './Axis2D.js';\nimport { SINGLE_REFERRING } from '../../util/model.js';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper.js';\nimport { isIntervalOrLogScale } from '../../scale/helper.js';\nimport { alignScaleTicks } from '../axisAlignTicks.js';\nvar Grid = /** @class */function () {\n  function Grid(gridModel, ecModel, api) {\n    // FIXME:TS where used (different from registered type 'cartesian2d')?\n    this.type = 'grid';\n    this._coordsMap = {};\n    this._coordsList = [];\n    this._axesMap = {};\n    this._axesList = [];\n    this.axisPointerEnabled = true;\n    this.dimensions = cartesian2DDimensions;\n    this._initCartesian(gridModel, ecModel, api);\n    this.model = gridModel;\n  }\n  Grid.prototype.getRect = function () {\n    return this._rect;\n  };\n  Grid.prototype.update = function (ecModel, api) {\n    var axesMap = this._axesMap;\n    this._updateScale(ecModel, this.model);\n    function updateAxisTicks(axes) {\n      var alignTo;\n      // Axis is added in order of axisIndex.\n      var axesIndices = keys(axes);\n      var len = axesIndices.length;\n      if (!len) {\n        return;\n      }\n      var axisNeedsAlign = [];\n      // Process once and calculate the ticks for those don't use alignTicks.\n      for (var i = len - 1; i >= 0; i--) {\n        var idx = +axesIndices[i]; // Convert to number.\n        var axis = axes[idx];\n        var model = axis.model;\n        var scale = axis.scale;\n        if (\n        // Only value and log axis without interval support alignTicks.\n        isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {\n          axisNeedsAlign.push(axis);\n        } else {\n          niceScaleExtent(scale, model);\n          if (isIntervalOrLogScale(scale)) {\n            // Can only align to interval or log axis.\n            alignTo = axis;\n          }\n        }\n      }\n      ;\n      // All axes has set alignTicks. Pick the first one.\n      // PENDING. Should we find the axis that both set interval, min, max and align to this one?\n      if (axisNeedsAlign.length) {\n        if (!alignTo) {\n          alignTo = axisNeedsAlign.pop();\n          niceScaleExtent(alignTo.scale, alignTo.model);\n        }\n        each(axisNeedsAlign, function (axis) {\n          alignScaleTicks(axis.scale, axis.model, alignTo.scale);\n        });\n      }\n    }\n    updateAxisTicks(axesMap.x);\n    updateAxisTicks(axesMap.y);\n    // Key: axisDim_axisIndex, value: boolean, whether onZero target.\n    var onZeroRecords = {};\n    each(axesMap.x, function (xAxis) {\n      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n    });\n    each(axesMap.y, function (yAxis) {\n      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n    });\n    // Resize again if containLabel is enabled\n    // FIXME It may cause getting wrong grid size in data processing stage\n    this.resize(this.model, api);\n  };\n  /**\r\n   * Resize the grid\r\n   */\n  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n    var boxLayoutParams = gridModel.getBoxLayoutParams();\n    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n    var gridRect = getLayoutRect(boxLayoutParams, {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    this._rect = gridRect;\n    var axesList = this._axesList;\n    adjustAxes();\n    // Minus label size\n    if (isContainLabel) {\n      each(axesList, function (axis) {\n        if (!axis.model.get(['axisLabel', 'inside'])) {\n          var labelUnionRect = estimateLabelUnionRect(axis);\n          if (labelUnionRect) {\n            var dim = axis.isHorizontal() ? 'height' : 'width';\n            var margin = axis.model.get(['axisLabel', 'margin']);\n            gridRect[dim] -= labelUnionRect[dim] + margin;\n            if (axis.position === 'top') {\n              gridRect.y += labelUnionRect.height + margin;\n            } else if (axis.position === 'left') {\n              gridRect.x += labelUnionRect.width + margin;\n            }\n          }\n        }\n      });\n      adjustAxes();\n    }\n    each(this._coordsList, function (coord) {\n      // Calculate affine matrix to accelerate the data to point transform.\n      // If all the axes scales are time or value.\n      coord.calcAffineTransform();\n    });\n    function adjustAxes() {\n      each(axesList, function (axis) {\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n        var idx = axis.inverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n      });\n    }\n  };\n  Grid.prototype.getAxis = function (dim, axisIndex) {\n    var axesMapOnDim = this._axesMap[dim];\n    if (axesMapOnDim != null) {\n      return axesMapOnDim[axisIndex || 0];\n    }\n  };\n  Grid.prototype.getAxes = function () {\n    return this._axesList.slice();\n  };\n  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n    if (xAxisIndex != null && yAxisIndex != null) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      return this._coordsMap[key];\n    }\n    if (isObject(xAxisIndex)) {\n      yAxisIndex = xAxisIndex.yAxisIndex;\n      xAxisIndex = xAxisIndex.xAxisIndex;\n    }\n    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n        return coordList[i];\n      }\n    }\n  };\n  Grid.prototype.getCartesians = function () {\n    return this._coordsList.slice();\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n    var target = this._findConvertTarget(finder);\n    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n  };\n  Grid.prototype._findConvertTarget = function (finder) {\n    var seriesModel = finder.seriesModel;\n    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    var gridModel = finder.gridModel;\n    var coordsList = this._coordsList;\n    var cartesian;\n    var axis;\n    if (seriesModel) {\n      cartesian = seriesModel.coordinateSystem;\n      indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n    } else if (xAxisModel && yAxisModel) {\n      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    } else if (xAxisModel) {\n      axis = this.getAxis('x', xAxisModel.componentIndex);\n    } else if (yAxisModel) {\n      axis = this.getAxis('y', yAxisModel.componentIndex);\n    }\n    // Lowest priority.\n    else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n    return {\n      cartesian: cartesian,\n      axis: axis\n    };\n  };\n  /**\r\n   * @implements\r\n   */\n  Grid.prototype.containPoint = function (point) {\n    var coord = this._coordsList[0];\n    if (coord) {\n      return coord.containPoint(point);\n    }\n  };\n  /**\r\n   * Initialize cartesian coordinate systems\r\n   */\n  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n    var _this = this;\n    var grid = this;\n    var axisPositionUsed = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false\n    };\n    var axesMap = {\n      x: {},\n      y: {}\n    };\n    var axesCount = {\n      x: 0,\n      y: 0\n    };\n    // Create axis\n    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n    if (!axesCount.x || !axesCount.y) {\n      // Roll back when there no either x or y axis\n      this._axesMap = {};\n      this._axesList = [];\n      return;\n    }\n    this._axesMap = axesMap;\n    // Create cartesian2d\n    each(axesMap.x, function (xAxis, xAxisIndex) {\n      each(axesMap.y, function (yAxis, yAxisIndex) {\n        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n        var cartesian = new Cartesian2D(key);\n        cartesian.master = _this;\n        cartesian.model = gridModel;\n        _this._coordsMap[key] = cartesian;\n        _this._coordsList.push(cartesian);\n        cartesian.addAxis(xAxis);\n        cartesian.addAxis(yAxis);\n      });\n    });\n    function createAxisCreator(dimName) {\n      return function (axisModel, idx) {\n        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n          return;\n        }\n        var axisPosition = axisModel.get('position');\n        if (dimName === 'x') {\n          // Fix position\n          if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n            // Default bottom of X\n            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n          }\n        } else {\n          // Fix position\n          if (axisPosition !== 'left' && axisPosition !== 'right') {\n            // Default left of Y\n            axisPosition = axisPositionUsed.left ? 'right' : 'left';\n          }\n        }\n        axisPositionUsed[axisPosition] = true;\n        var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        // Inject axis into axisModel\n        axisModel.axis = axis;\n        // Inject axisModel into axis\n        axis.model = axisModel;\n        // Inject grid info axis\n        axis.grid = grid;\n        // Index of axis, can be used as key\n        axis.index = idx;\n        grid._axesList.push(axis);\n        axesMap[dimName][idx] = axis;\n        axesCount[dimName]++;\n      };\n    }\n  };\n  /**\r\n   * Update cartesian properties from series.\r\n   */\n  Grid.prototype._updateScale = function (ecModel, gridModel) {\n    // Reset scale\n    each(this._axesList, function (axis) {\n      axis.scale.setExtent(Infinity, -Infinity);\n      if (axis.type === 'category') {\n        var categorySortInfo = axis.model.get('categorySortInfo');\n        axis.scale.setSortInfo(categorySortInfo);\n      }\n    });\n    ecModel.eachSeries(function (seriesModel) {\n      if (isCartesian2DSeries(seriesModel)) {\n        var axesModelMap = findAxisModels(seriesModel);\n        var xAxisModel = axesModelMap.xAxisModel;\n        var yAxisModel = axesModelMap.yAxisModel;\n        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n          return;\n        }\n        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        var data = seriesModel.getData();\n        var xAxis = cartesian.getAxis('x');\n        var yAxis = cartesian.getAxis('y');\n        unionExtent(data, xAxis);\n        unionExtent(data, yAxis);\n      }\n    }, this);\n    function unionExtent(data, axis) {\n      each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n        axis.scale.unionExtentFromData(data, dim);\n      });\n    }\n  };\n  /**\r\n   * @param dim 'x' or 'y' or 'auto' or null/undefined\r\n   */\n  Grid.prototype.getTooltipAxes = function (dim) {\n    var baseAxes = [];\n    var otherAxes = [];\n    each(this.getCartesians(), function (cartesian) {\n      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n      var otherAxis = cartesian.getOtherAxis(baseAxis);\n      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n    });\n    return {\n      baseAxes: baseAxes,\n      otherAxes: otherAxes\n    };\n  };\n  Grid.create = function (ecModel, api) {\n    var grids = [];\n    ecModel.eachComponent('grid', function (gridModel, idx) {\n      var grid = new Grid(gridModel, ecModel, api);\n      grid.name = 'grid_' + idx;\n      // dataSampling requires axis extent, so resize\n      // should be performed in create stage.\n      grid.resize(gridModel, api, true);\n      gridModel.coordinateSystem = grid;\n      grids.push(grid);\n    });\n    // Inject the coordinateSystems into seriesModel\n    ecModel.eachSeries(function (seriesModel) {\n      if (!isCartesian2DSeries(seriesModel)) {\n        return;\n      }\n      var axesModelMap = findAxisModels(seriesModel);\n      var xAxisModel = axesModelMap.xAxisModel;\n      var yAxisModel = axesModelMap.yAxisModel;\n      var gridModel = xAxisModel.getCoordSysModel();\n      if (process.env.NODE_ENV !== 'production') {\n        if (!gridModel) {\n          throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n        }\n        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n          throw new Error('xAxis and yAxis must use the same grid');\n        }\n      }\n      var grid = gridModel.coordinateSystem;\n      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n    });\n    return grids;\n  };\n  // For deciding which dimensions to use when creating list data\n  Grid.dimensions = cartesian2DDimensions;\n  return Grid;\n}();\n/**\r\n * Check if the axis is used in the specified grid.\r\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis,\n// Key: see `getOnZeroRecordKey`\nonZeroRecords) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n  };\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxisOnZeroOf;\n  var axisModel = axis.model;\n  var onZero = axisModel.get(['axisLine', 'onZero']);\n  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n  if (!onZero) {\n    return;\n  }\n  // If target axis is specified.\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n    }\n  } else {\n    // Find the first available other axis.\n    for (var idx in otherAxes) {\n      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])\n      // Consider that two Y axes on one value axis,\n      // if both onZero, the two Y axes overlap.\n      && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n        otherAxisOnZeroOf = otherAxes[idx];\n        break;\n      }\n    }\n  }\n  if (otherAxisOnZeroOf) {\n    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n  }\n  function getOnZeroRecordKey(axis) {\n    return axis.dim + '_' + axis.index;\n  }\n}\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1];\n  // Fast transform\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\nexport default Grid;"],
  "mappings": "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",
  "names": ["Cartesian", "Cartesian2D", "Axis2D", "Grid", "axis"]
}
