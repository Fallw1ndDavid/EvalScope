{
  "version": 3,
  "sources": ["../../echarts/lib/coord/axisTickLabelBuilder.js", "../../echarts/lib/coord/axis.js"],
  "sourcesContent": ["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as textContain from 'zrender/lib/contain/text.js';\nimport { makeInner } from '../util/model.js';\nimport { makeLabelFormatter, getOptionCategoryInterval, shouldShowAllLabels } from './axisHelper.js';\nvar inner = makeInner();\nfunction tickValuesToNumbers(axis, values) {\n  var nums = zrUtil.map(values, function (val) {\n    return axis.scale.parse(val);\n  });\n  if (axis.type === 'time' && nums.length > 0) {\n    // Time axis needs duplicate first/last tick (see TimeScale.getTicks())\n    // The first and last tick/label don't get drawn\n    nums.sort();\n    nums.unshift(nums[0]);\n    nums.push(nums[nums.length - 1]);\n  }\n  return nums;\n}\nexport function createAxisLabels(axis) {\n  var custom = axis.getLabelModel().get('customValues');\n  if (custom) {\n    var labelFormatter_1 = makeLabelFormatter(axis);\n    var extent_1 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    var ticks = zrUtil.filter(tickNumbers, function (val) {\n      return val >= extent_1[0] && val <= extent_1[1];\n    });\n    return {\n      labels: zrUtil.map(ticks, function (numval) {\n        var tick = {\n          value: numval\n        };\n        return {\n          formattedLabel: labelFormatter_1(tick),\n          rawLabel: axis.scale.getLabel(tick),\n          tickValue: numval\n        };\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n/**\r\n * @param {module:echats/coord/Axis} axis\r\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\r\n * @return {Object} {\r\n *     ticks: Array.<number>\r\n *     tickCategoryInterval: number\r\n * }\r\n */\nexport function createAxisTicks(axis, tickModel) {\n  var custom = axis.getTickModel().get('customValues');\n  if (custom) {\n    var extent_2 = axis.scale.getExtent();\n    var tickNumbers = tickValuesToNumbers(axis, custom);\n    return {\n      ticks: zrUtil.filter(tickNumbers, function (val) {\n        return val >= extent_2[0] && val <= extent_2[1];\n      })\n    };\n  }\n  // Only ordinal scale support tick interval\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n  if (result) {\n    return result;\n  }\n  var labels;\n  var numericLabelInterval;\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n  if (result) {\n    return result;\n  }\n  var ticks;\n  var tickCategoryInterval;\n  // Optimize for the case that large category data and no label displayed,\n  // we should not return all ticks.\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  }\n  // Always use label interval by default despite label show. Consider this\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\n  else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n  // Cache to avoid calling interval function repeatedly.\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        level: tick.level,\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\nfunction getListCache(axis, prop) {\n  // Because key can be a function, and cache size always is small, we use array cache.\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n/**\r\n * Calculate interval for category axis ticks and labels.\r\n * To get precise result, at least one of `getRotate` and `isHorizontal`\r\n * should be implemented in axis.\r\n */\nexport function calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  // Providing this method is for optimization:\n  // avoid generating a long array by `getTicks`\n  // in large category data case.\n  var tickCount = ordinalScale.count();\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n  var step = 1;\n  // Simple optimization. Empirical value: tick count should less than 40.\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n  // Caution: Performance sensitive for large category data.\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    // Not precise, do not consider align and vertical align\n    // and each distance from axis line yet.\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    // Magic number\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    // Min size, void long loop.\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  // 0/0 is NaN, 1/0 is Infinity.\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n  // Use cache to keep interval stable while moving zoom window,\n  // otherwise the calculated interval might jitter when the zoom\n  // window size is close to the interval-changing size.\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\n  // The jitter will cause that sometimes the displayed labels are\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1\n  // Always choose the bigger one, otherwise the critical\n  // point is not the same when zooming in or zooming out.\n  && lastAutoInterval > interval\n  // If the axis change is caused by chart resize, the cache should not\n  // be used. Otherwise some hidden labels might not be shown again.\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  }\n  // Only update cache if cache not used, otherwise the\n  // changing of interval is too insensitive.\n  else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n  return interval;\n}\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n  // Calculate start tick based on zero if possible to keep label consistent\n  // while zooming and moving while interval > 0. Otherwise the selection\n  // of displayable ticks and symbols probably keep changing.\n  // 3 is empirical value.\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n  // (1) Only add min max label here but leave overlap checking\n  // to render stage, which also ensure the returned list\n  // suitable for splitLine and splitArea rendering.\n  // (2) Scales except category always contain min max label so\n  // do not need to perform this process.\n  var showAllLabel = shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n  // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\n  var tickValue = startTick;\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n  return result;\n}\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}", "\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { each, map } from 'zrender/lib/core/util.js';\nimport { linearMap, getPixelPrecision, round } from '../util/number.js';\nimport { createAxisTicks, createAxisLabels, calculateCategoryInterval } from './axisTickLabelBuilder.js';\nvar NORMALIZED_EXTENT = [0, 1];\n/**\r\n * Base class of Axis.\r\n */\nvar Axis = /** @class */function () {\n  function Axis(dim, scale, extent) {\n    this.onBand = false;\n    this.inverse = false;\n    this.dim = dim;\n    this.scale = scale;\n    this._extent = extent || [0, 0];\n  }\n  /**\r\n   * If axis extent contain given coord\r\n   */\n  Axis.prototype.contain = function (coord) {\n    var extent = this._extent;\n    var min = Math.min(extent[0], extent[1]);\n    var max = Math.max(extent[0], extent[1]);\n    return coord >= min && coord <= max;\n  };\n  /**\r\n   * If axis extent contain given data\r\n   */\n  Axis.prototype.containData = function (data) {\n    return this.scale.contain(data);\n  };\n  /**\r\n   * Get coord extent.\r\n   */\n  Axis.prototype.getExtent = function () {\n    return this._extent.slice();\n  };\n  /**\r\n   * Get precision used for formatting\r\n   */\n  Axis.prototype.getPixelPrecision = function (dataExtent) {\n    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n  };\n  /**\r\n   * Set coord extent\r\n   */\n  Axis.prototype.setExtent = function (start, end) {\n    var extent = this._extent;\n    extent[0] = start;\n    extent[1] = end;\n  };\n  /**\r\n   * Convert data to coord. Data is the rank if it has an ordinal scale\r\n   */\n  Axis.prototype.dataToCoord = function (data, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    data = scale.normalize(data);\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n    return linearMap(data, NORMALIZED_EXTENT, extent, clamp);\n  };\n  /**\r\n   * Convert coord to data. Data is the rank if it has an ordinal scale\r\n   */\n  Axis.prototype.coordToData = function (coord, clamp) {\n    var extent = this._extent;\n    var scale = this.scale;\n    if (this.onBand && scale.type === 'ordinal') {\n      extent = extent.slice();\n      fixExtentWithBands(extent, scale.count());\n    }\n    var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);\n    return this.scale.scale(t);\n  };\n  /**\r\n   * Convert pixel point to data in axis\r\n   */\n  Axis.prototype.pointToData = function (point, clamp) {\n    // Should be implemented in derived class if necessary.\n    return;\n  };\n  /**\r\n   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,\r\n   * `axis.getTicksCoords` considers `onBand`, which is used by\r\n   * `boundaryGap:true` of category axis and splitLine and splitArea.\r\n   * @param opt.tickModel default: axis.model.getModel('axisTick')\r\n   * @param opt.clamp If `true`, the first and the last\r\n   *        tick must be at the axis end points. Otherwise, clip ticks\r\n   *        that outside the axis extent.\r\n   */\n  Axis.prototype.getTicksCoords = function (opt) {\n    opt = opt || {};\n    var tickModel = opt.tickModel || this.getTickModel();\n    var result = createAxisTicks(this, tickModel);\n    var ticks = result.ticks;\n    var ticksCoords = map(ticks, function (tickVal) {\n      return {\n        coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),\n        tickValue: tickVal\n      };\n    }, this);\n    var alignWithLabel = tickModel.get('alignWithLabel');\n    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);\n    return ticksCoords;\n  };\n  Axis.prototype.getMinorTicksCoords = function () {\n    if (this.scale.type === 'ordinal') {\n      // Category axis doesn't support minor ticks\n      return [];\n    }\n    var minorTickModel = this.model.getModel('minorTick');\n    var splitNumber = minorTickModel.get('splitNumber');\n    // Protection.\n    if (!(splitNumber > 0 && splitNumber < 100)) {\n      splitNumber = 5;\n    }\n    var minorTicks = this.scale.getMinorTicks(splitNumber);\n    var minorTicksCoords = map(minorTicks, function (minorTicksGroup) {\n      return map(minorTicksGroup, function (minorTick) {\n        return {\n          coord: this.dataToCoord(minorTick),\n          tickValue: minorTick\n        };\n      }, this);\n    }, this);\n    return minorTicksCoords;\n  };\n  Axis.prototype.getViewLabels = function () {\n    return createAxisLabels(this).labels;\n  };\n  Axis.prototype.getLabelModel = function () {\n    return this.model.getModel('axisLabel');\n  };\n  /**\r\n   * Notice here we only get the default tick model. For splitLine\r\n   * or splitArea, we should pass the splitLineModel or splitAreaModel\r\n   * manually when calling `getTicksCoords`.\r\n   * In GL, this method may be overridden to:\r\n   * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`\r\n   */\n  Axis.prototype.getTickModel = function () {\n    return this.model.getModel('axisTick');\n  };\n  /**\r\n   * Get width of band\r\n   */\n  Axis.prototype.getBandWidth = function () {\n    var axisExtent = this._extent;\n    var dataExtent = this.scale.getExtent();\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n    // Fix #2728, avoid NaN when only one data.\n    len === 0 && (len = 1);\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\n    return Math.abs(size) / len;\n  };\n  /**\r\n   * Only be called in category axis.\r\n   * Can be overridden, consider other axes like in 3D.\r\n   * @return Auto interval for cateogry axis tick and label\r\n   */\n  Axis.prototype.calculateCategoryInterval = function () {\n    return calculateCategoryInterval(this);\n  };\n  return Axis;\n}();\nfunction fixExtentWithBands(extent, nTick) {\n  var size = extent[1] - extent[0];\n  var len = nTick;\n  var margin = size / len / 2;\n  extent[0] += margin;\n  extent[1] -= margin;\n}\n// If axis has labels [1, 2, 3, 4]. Bands on the axis are\n// |---1---|---2---|---3---|---4---|.\n// So the displayed ticks and splitLine/splitArea should between\n// each data item, otherwise cause misleading (e.g., split tow bars\n// of a single data item when there are two bar series).\n// Also consider if tickCategoryInterval > 0 and onBand, ticks and\n// splitLine/spliteArea should layout appropriately corresponding\n// to displayed labels. (So we should not use `getBandWidth` in this\n// case).\nfunction fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {\n  var ticksLen = ticksCoords.length;\n  if (!axis.onBand || alignWithLabel || !ticksLen) {\n    return;\n  }\n  var axisExtent = axis.getExtent();\n  var last;\n  var diffSize;\n  if (ticksLen === 1) {\n    ticksCoords[0].coord = axisExtent[0];\n    last = ticksCoords[1] = {\n      coord: axisExtent[1],\n      tickValue: ticksCoords[0].tickValue\n    };\n  } else {\n    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;\n    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;\n    each(ticksCoords, function (ticksItem) {\n      ticksItem.coord -= shift_1 / 2;\n    });\n    var dataExtent = axis.scale.getExtent();\n    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;\n    last = {\n      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize,\n      tickValue: dataExtent[1] + 1\n    };\n    ticksCoords.push(last);\n  }\n  var inverse = axisExtent[0] > axisExtent[1];\n  // Handling clamp.\n  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {\n    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();\n  }\n  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {\n    ticksCoords.unshift({\n      coord: axisExtent[0]\n    });\n  }\n  if (littleThan(axisExtent[1], last.coord)) {\n    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();\n  }\n  if (clamp && littleThan(last.coord, axisExtent[1])) {\n    ticksCoords.push({\n      coord: axisExtent[1]\n    });\n  }\n  function littleThan(a, b) {\n    // Avoid rounding error cause calculated tick coord different with extent.\n    // It may cause an extra unnecessary tick added.\n    a = round(a);\n    b = round(b);\n    return inverse ? a > b : a < b;\n  }\n}\nexport default Axis;"],
  "mappings": "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",
  "names": ["tickValue", "Axis"]
}
