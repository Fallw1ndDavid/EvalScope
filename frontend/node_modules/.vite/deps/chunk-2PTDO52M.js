import {
  findAxisModels,
  isCartesian2DSeries
} from "./chunk-VELEHINS.js";
import {
  axis_default
} from "./chunk-V6AOWI3R.js";
import {
  Interval_default,
  createScaleByModel,
  estimateLabelUnionRect,
  getDataDimensionsOnAxis,
  getScaleExtent,
  ifAxisCrossZero,
  increaseInterval,
  isIntervalOrLogScale,
  isValueNice,
  niceScaleExtent
} from "./chunk-M4POZINQ.js";
import {
  getLayoutRect
} from "./chunk-GB6GZOYA.js";
import {
  BoundingRect_default,
  SINGLE_REFERRING,
  __extends,
  applyTransform,
  each,
  filter,
  getPrecisionSafe,
  indexOf,
  invert,
  isObject,
  keys,
  map,
  retrieve3,
  round,
  warn
} from "./chunk-D2XYPIYM.js";

// node_modules/echarts/lib/coord/cartesian/Cartesian.js
var Cartesian = function() {
  function Cartesian2(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian_default = Cartesian;

// node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale) {
  return scale.type === "interval" || scale.type === "time";
}
var Cartesian2D = function(_super) {
  __extends(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end[0] - start[0]) / xScaleSpan;
    var scaleY = (end[1] - start[1]) / yScaleSpan;
    var translateX = start[0] - xScaleExtent[0] * scaleX;
    var translateY = start[1] - yScaleExtent[0] * scaleY;
    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };
  Cartesian2D2.prototype.containData = function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  };
  Cartesian2D2.prototype.containZone = function(data1, data2) {
    var zoneDiag1 = this.dataToPoint(data1);
    var zoneDiag2 = this.dataToPoint(data2);
    var area = this.getArea();
    var zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  };
  Cartesian2D2.prototype.dataToPoint = function(data, clamp, out) {
    out = out || [];
    var xVal = data[0];
    var yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform(out, data, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp));
    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp));
    return out;
  };
  Cartesian2D2.prototype.clampData = function(data, out) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out = out || [];
    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out;
  };
  Cartesian2D2.prototype.pointToData = function(point, clamp) {
    var out = [];
    if (this._invTransform) {
      return applyTransform(out, point, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp);
    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp);
    return out;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function(tolerance) {
    tolerance = tolerance || 0;
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x = Math.min(xExtent[0], xExtent[1]) - tolerance;
    var y = Math.min(yExtent[0], yExtent[1]) - tolerance;
    var width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;
    var height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;
    return new BoundingRect_default(x, y, width, height);
  };
  return Cartesian2D2;
}(Cartesian_default);
var Cartesian2D_default = Cartesian2D;

// node_modules/echarts/lib/coord/cartesian/Axis2D.js
var Axis2D = function(_super) {
  __extends(Axis2D2, _super);
  function Axis2D2(dim, scale, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position = this.position;
    return position === "top" || position === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc && ret[0] > ret[1] && ret.reverse();
    return ret;
  };
  Axis2D2.prototype.pointToData = function(point, clamp) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };
  return Axis2D2;
}(axis_default);
var Axis2D_default = Axis2D;

// node_modules/echarts/lib/coord/axisAlignTicks.js
var mathLog = Math.log;
function alignScaleTicks(scale, axisModel, alignToScale) {
  var intervalScaleProto = Interval_default.prototype;
  var alignToTicks = intervalScaleProto.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale.type === "log") {
    var logBase = mathLog(scale.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }
  scale.setExtent(rawExtent[0], rawExtent[1]);
  scale.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent = intervalScaleProto.getExtent.call(scale);
  if (isMinFixed) {
    rawExtent[0] = extent[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent[1];
  }
  var interval = intervalScaleProto.getInterval.call(scale);
  var min = rawExtent[0];
  var max = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max - min) / alignToSplitNumber;
  } else if (isMinFixed) {
    max = rawExtent[0] + interval * alignToSplitNumber;
    while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min = rawExtent[1] - interval * alignToSplitNumber;
    while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range = interval * alignToSplitNumber;
    max = Math.ceil(rawExtent[1] / interval) * interval;
    min = round(max - range);
    if (min < 0 && rawExtent[0] >= 0) {
      min = 0;
      max = round(range);
    } else if (max > 0 && rawExtent[1] <= 0) {
      max = 0;
      min = -round(range);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1);
  intervalScaleProto.setInterval.call(scale, interval);
  if (t0 || t1) {
    intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval);
  }
  if (true) {
    var ticks = intervalScaleProto.getTicks.call(scale);
    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn(
        "The ticks may be not readable when set min: " + axisModel.get("min") + ", max: " + axisModel.get("max") + " and alignTicks: true"
      );
    }
  }
}

// node_modules/echarts/lib/coord/cartesian/Grid.js
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys(axes);
      var len = axesIndices.length;
      if (!len) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i = len - 1; i >= 0; i--) {
        var idx = +axesIndices[i];
        var axis = axes[idx];
        var model = axis.model;
        var scale = axis.scale;
        if (isIntervalOrLogScale(scale) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale, model);
          if (isIntervalOrLogScale(scale)) {
            alignTo = axis;
          }
        }
      }
      ;
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each(axesMap.x, function(xAxis, xAxisIndex) {
      each(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D_default(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;
        _this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D_default(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory = axis.type === "category";
        axis.onBand = isCategory && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid = new Grid2(gridModel, ecModel, api);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      if (true) {
        if (!gridModel) {
          throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
        }
        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error("xAxis and yAxis must use the same grid");
        }
      }
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid_default = Grid;

export {
  alignScaleTicks,
  Grid_default
};
//# sourceMappingURL=chunk-2PTDO52M.js.map
